/*
  monitor_saude_esp32_mqtt.ino
  Simulação Wokwi + MQTT real via broker.emqx.io
  - ESP32 DevKit V1
  - LCD 16x2
  - Potenciômetro simula PPG (A0 -> ADC32)
  - LM35 (ADC34)
  - LEDs, buzzer, botão de emergência
  - Publica JSON em health/monitor/patient01 a cada 15s
*/

#include <WiFi.h>
#include <PubSubClient.h>
#include <LiquidCrystal.h>

// ---------- USER CONFIG ----------
const char* WIFI_SSID = "Wokwi-GUEST"; // troque se necessário
const char* WIFI_PASS = "";

const char* MQTT_SERVER = "broker.emqx.io";
const uint16_t MQTT_PORT = 1883;
const char* MQTT_TOPIC = "health/monitor/patient01";

// ---------- PINS (match diagram.json) ----------
#define LCD_RS 12
#define LCD_EN 14
#define LCD_D4 27
#define LCD_D5 26
#define LCD_D6 25
#define LCD_D7 33

#define PIN_POT 32     // ADC -> heart simulation
#define PIN_LM35 34    // ADC -> temp sensor
#define PIN_HEART_LED 15
#define PIN_WIFI_LED 2
#define PIN_BUZZER 4
#define PIN_BTN 13

// ---------- TIMINGS ----------
const unsigned long UPDATE_INTERVAL = 1000;    // LCD update (ms)
const unsigned long MQTT_INTERVAL = 15000;     // MQTT publish (ms)

// ---------- GLOBALS ----------
LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);

WiFiClient espClient;
PubSubClient mqttClient(espClient);

float heartRate = 75.0;
float temperatureC = 36.5;
bool heartDetected = false;
unsigned long lastBeat = 0;
unsigned long lastUpdate = 0;
unsigned long lastMqtt = 0;
int beatCount = 0;
bool emergencyFlag = false;

// ---------- FUNCTIONS ----------
void connectWiFi() {
  Serial.print("Connecting to WiFi ");
  Serial.print(WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected. IP:");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi not connected (Wokwi guest may be used).");
  }
}

void connectMQTT() {
  mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
  while (!mqttClient.connected()) {
    Serial.print("Connecting to MQTT...");
    String clientId = String("ESP32_Health_") + String(random(0xffff), HEX);
    if (mqttClient.connect(clientId.c_str())) {
      Serial.println("connected");
    } else {
      Serial.print("failed, rc=");
      Serial.println(mqttClient.state());
      delay(2000);
    }
  }
}

void publishToMQTT() {
  if (!mqttClient.connected()) connectMQTT();
  String payload = "{";
  payload += "\"bpm\":" + String(heartRate,1) + ",";
  payload += "\"temp\":" + String(temperatureC,1) + ",";
  payload += "\"beats\":" + String(beatCount) + ",";
  payload += "\"state\":\"" + String(emergencyFlag ? "emergency" : "normal") + "\",";
  payload += "\"ts\":" + String(millis()/1000);
  payload += "}";
  bool ok = mqttClient.publish(MQTT_TOPIC, payload.c_str());
  Serial.println(String("Published MQTT: ") + payload + " -> " + (ok?"OK":"FAIL"));
  digitalWrite(PIN_WIFI_LED, HIGH);
  delay(500);
  digitalWrite(PIN_WIFI_LED, LOW);
}

void detectHeartbeat(int rawSignal) {
  static int threshold = 600; // for simulated ADC range (0-4095)
  static bool wasHigh = false;
  static unsigned long lastDetection = 0;

  if (rawSignal > threshold && !wasHigh) {
    wasHigh = true;
    unsigned long now = millis();
    if (lastBeat > 0) {
      unsigned long interval = now - lastBeat;
      if (interval > 300 && interval < 2000) {
        float instHR = 60000.0 / interval;
        static float smoothed = instHR;
        smoothed = smoothed * 0.7 + instHR * 0.3;
        heartRate = smoothed;
        beatCount++;
        // blink
        digitalWrite(PIN_HEART_LED, HIGH);
        delay(25);
        digitalWrite(PIN_HEART_LED, LOW);
        heartDetected = true;
        lastDetection = now;
      }
    }
    lastBeat = now;
  }

  if (rawSignal < threshold - 100) wasHigh = false;

  if (millis() - lastDetection > 2000) {
    heartDetected = false;
  }
}

void updateLCD() {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("BPM:");
  if (heartRate < 100) lcd.print(" ");
  lcd.print((int)heartRate);
  lcd.setCursor(11,0);
  lcd.print(beatCount % 10);

  lcd.setCursor(0,1);
  lcd.print("T:");
  lcd.print(temperatureC,1);
  lcd.print((char)223);
  lcd.print("C ");
  if (millis() - lastMqtt < 2000) lcd.print("W");
}

void checkAlarms() {
  if (emergencyFlag) {
    tone(PIN_BUZZER, 2000, 200);
    return;
  }
  if (heartRate > 120 || heartRate < 50) {
    // critical
    tone(PIN_BUZZER, 1500, 300);
  } else if (temperatureC > 38.0) {
    tone(PIN_BUZZER, 1200, 300);
  }
}

void handleButton() {
  static bool lastState = HIGH;
  bool cur = digitalRead(PIN_BTN);
  if (lastState == HIGH && cur == LOW) {
    emergencyFlag = !emergencyFlag;
    Serial.println(String("Emergency toggled: ") + (emergencyFlag?"ON":"OFF"));
    delay(50);
  }
  lastState = cur;
}

// ---------- SETUP & LOOP ----------
void setup() {
  Serial.begin(115200);
  delay(100);

  pinMode(PIN_HEART_LED, OUTPUT);
  pinMode(PIN_WIFI_LED, OUTPUT);
  pinMode(PIN_BUZZER, OUTPUT);
  pinMode(PIN_BTN, INPUT_PULLUP);

  lcd.begin(16,2);
  lcd.print("Health Monitor");
  lcd.setCursor(0,1);
  lcd.print("ESP32 + MQTT");
  delay(1500);

  connectWiFi();
  connectMQTT();

  lastUpdate = millis();
  lastMqtt = millis();
}

void loop() {
  mqttClient.loop();
  unsigned long now = millis();

  // Read simulated sensors
  int pot = analogRead(PIN_POT);   // 0-4095
  int lm = analogRead(PIN_LM35);   // 0-4095

  // Convert LM35 (assumes 3.3V ADC ref in Wokwi) => scale to 5V behaviour for LM35
  // In Wokwi, LM35 tied to 3.3V: voltage = raw*(3.3/4095)
  float voltage = lm * (3.3 / 4095.0);
  // If you expect 5V LM35, scale accordingly. Here we map to Celsius:
  temperatureC = voltage * 100.0; // LM35 ~10mV/°C, mapping 0-330C (but sim uses safe range)

  // Simulated heart detection (pot maps to 0-4095)
  detectHeartbeat(pot);

  // Button emergency
  handleButton();

  // Update LCD periodically
  if (now - lastUpdate >= UPDATE_INTERVAL) {
    updateLCD();
    lastUpdate = now;
  }

  // Publish to MQTT periodically
  if (now - lastMqtt >= MQTT_INTERVAL) {
    publishToMQTT();
    lastMqtt = now;
  }

  // Check alarms
  checkAlarms();

  delay(50);
}
