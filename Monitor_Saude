#include <Wire.h>
#include <WiFi.h>             // Troque por WiFiNINA.h ou WiFiS3.h se necessário para sua UNO R4
#include <PubSubClient.h>

// Bibliotecas dos sensores (instale via Library Manager)
#include <Adafruit_MAX30105.h>
#include <Adafruit_MLX90614.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>

// --- CONFIGURAÇÃO DO USUÁRIO ---
const char* ssid = "SEU_SSID";
const char* password = "SUA_SENHA_WIFI";

const char* mqtt_server = "broker.hivemq.com"; // exemplo público; substitua por broker seguro
const uint16_t mqtt_port = 1883;
const char* mqtt_user = ""; // se houver
const char* mqtt_pass = ""; // se houver

const char* topic_pub = "saude/camila/data";
const char* topic_sub = "saude/camila/commands";

const int BUZZER_PIN = 6;
const int LED_R = 9;
const int LED_G = 10;
const int LED_B = 11;

const float SPO2_THRESHOLD = 90.0; // em %
const float TEMP_THRESHOLD = 38.0; // em °C
const int BPM_MIN = 45;
const int BPM_MAX = 130;

// --- OBJETOS / VARIÁVEIS ---
WiFiClient espClient;
PubSubClient client(espClient);

Adafruit_MAX30105 maxSensor;
Adafruit_MLX90614 mlx = Adafruit_MLX90614();
Adafruit_MPU6050 mpu;

unsigned long lastPublish = 0;
const unsigned long PUBLISH_INTERVAL = 2000; // 2s

// Funções adiante
void mqttCallback(char* topic, byte* payload, unsigned int length);
void reconnect();
void setLEDColor(uint8_t r, uint8_t g, uint8_t b);
void beepBuzzer(int ms);

// --- SETUP ---
void setup() {
  Serial.begin(115200);
  delay(100);

  // pinos
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(LED_B, OUTPUT);
  setLEDColor(0, 0, 0);

  // I2C
  Wire.begin();

  // inicializa sensores
  if (!maxSensor.begin()) {
    Serial.println("MAX30105 nao encontrado. Verifique conexoes.");
  } else {
    Serial.println("MAX30105 iniciado.");
    // configurações iniciais sensoriamento (ajuste conforme necessidade)
    maxSensor.setup(); // usa valores padrões; para maior robustez, ajustar led pulse, sample rate, etc.
  }

  if (!mlx.begin()) {
    Serial.println("MLX90614 nao encontrado.");
  } else {
    Serial.println("MLX90614 iniciado.");
  }

  if (!mpu.begin()) {
    Serial.println("MPU6050 nao encontrado.");
  } else {
    Serial.println("MPU6050 iniciado.");
  }

  // WiFi
  Serial.println("Conectando WiFi...");
  WiFi.begin(ssid, password);
  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 20) {
    delay(500);
    Serial.print(".");
    retries++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi conectado.");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    setLEDColor(0, 0, 255); // azul = tentando envio
  } else {
    Serial.println("\nFalha WiFi.");
    setLEDColor(255, 0, 0); // vermelho
  }

  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(mqttCallback);
}

// --- LOOP ---
void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  unsigned long now = millis();
  if (now - lastPublish >= PUBLISH_INTERVAL) {
    lastPublish = now;

    // Leitura MAX30102 -> estimativa de BPM e SPO2
    // Nota: leituras PPG requerem processamento; aqui apresentamos exemplo simplificado.
    float spo2 = NAN;
    int bpm = 0;

    // coletar amostra simples (para protótipo). Para produção, aplicar algoritmo PPG robusto.
    if (maxSensor.available()) {
      // lê valores brutos apenas para exemplo — para cálculo real, usar bibliotecas que retornam BPM/SpO2
      long ir = maxSensor.getIR();
      long red = maxSensor.getRed();
      // Exemplo grosseiro de cálculo fictício (substituir por algoritmo real)
      if (ir > 0) {
        // pseudo-cálculo
        bpm = 70 + (ir % 10); // apenas placeholder
        spo2 = 95.0 + ((red - ir) % 3); // placeholder
      }
      maxSensor.nextSample();
    } else {
      // tente obter uma leitura solicitando sensoriamento
      maxSensor.check(); // método dependendo da lib
    }

    // Leitura temperatura via MLX90614
    float temp = mlx.readObjectTempC();

    // Leitura MPU6050 -> passos (aqui usamos aceleração magnitude simplificada)
    sensors_event_t a, g, tempEvent;
    mpu.getEvent(&a, &g, &tempEvent);
    float accelMagnitude = sqrt(a.acceleration.x*a.acceleration.x + a.acceleration.y*a.acceleration.y + a.acceleration.z*a.acceleration.z);
    // heurística simples para passos (exemplo)
    static int stepCount = 0;
    if (accelMagnitude > 12.0) { // valor experimental
      stepCount++;
    }

    // Monta payload JSON
    String payload = "{";
    payload += "\"bpm\":" + String(bpm) + ",";
    payload += "\"spo2\":" + (isnan(spo2) ? String("null") : String(spo2,1)) + ",";
    payload += "\"temp\":" + String(temp,2) + ",";
    payload += "\"steps\":" + String(stepCount) + ",";
    payload += "\"ts\":" + String(now);
    payload += "}";

    // Publica
    Serial.print("Publicando: ");
    Serial.println(payload);
    if (client.publish(topic_pub, payload.c_str())) {
      Serial.println("Publicado com sucesso.");
      setLEDColor(0, 255, 0); // verde
      delay(150);
      setLEDColor(0, 0, 255); // volta azul (enviando)
    } else {
      Serial.println("Falha ao publicar.");
      setLEDColor(255, 0, 0);
    }

    // Verifica se valores fora do normal -> aciona atuadores locais e publica alerta
    bool alert = false;
    String alertMsg = "";
    if (!isnan(spo2) && spo2 < SPO2_THRESHOLD) {
      alert = true;
      alertMsg += "SpO2 baixo;";
    }
    if (temp > TEMP_THRESHOLD) {
      alert = true;
      alertMsg += "Temperatura alta;";
    }
    if (bpm < BPM_MIN || bpm > BPM_MAX) {
      alert = true;
      alertMsg += "BPM fora;";
    }

    if (alert) {
      // aciona buzzer e LED vermelho
      beepBuzzer(400);
      setLEDColor(255, 0, 0);
      // publica alerta
      String apayload = "{\"alert\":1,\"message\":\"" + alertMsg + "\"}";
      client.publish("saude/camila/alertas", apayload.c_str());
    }
  } // fim publish interval
}

// --- FUNCOES ---
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Mensagem recebida [");
  Serial.print(topic);
  Serial.println("]");

  String msg = "";
  for (unsigned int i = 0; i < length; i++) {
    msg += (char)payload[i];
  }
  Serial.print("Payload: ");
  Serial.println(msg);

  // Exemplo simples: comando JSON { "cmd":"buzz", "dur":500 } ou { "cmd":"led","color":"green" }
  if (msg.indexOf("buzz") >= 0) {
    // extrair duração se disponível
    int dur = 300;
    int idx = msg.indexOf("dur");
    if (idx >= 0) {
      // parsing simples
      int colon = msg.indexOf(":", idx);
      int comma = msg.indexOf(",", colon);
      if (colon >= 0) {
        String num = "";
        for (int i = colon+1; i < colon+6 && i < (int)msg.length(); i++) {
          if (isDigit(msg[i])) num += msg[i];
        }
        if (num.length()) dur = num.toInt();
      }
    }
    beepBuzzer(dur);
  } else if (msg.indexOf("led") >= 0) {
    if (msg.indexOf("green") >= 0) setLEDColor(0,255,0);
    else if (msg.indexOf("red") >= 0) setLEDColor(255,0,0);
    else if (msg.indexOf("blue") >= 0) setLEDColor(0,0,255);
  }
}

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Conectando MQTT...");
    String clientId = "UNO_R4_";
    clientId += String(random(0xffff), HEX);
    if (client.connect(clientId.c_str(), mqtt_user, mqtt_pass)) {
      Serial.println("conectado");
      // se conectado, subscribe
      client.subscribe(topic_sub);
    } else {
      Serial.print("falha, rc=");
      Serial.print(client.state());
      Serial.println(" tentando novamente em 2s");
      delay(2000);
    }
  }
}

void setLEDColor(uint8_t r, uint8_t g, uint8_t b) {
  analogWrite(LED_R, r);
  analogWrite(LED_G, g);
  analogWrite(LED_B, b);
}

void beepBuzzer(int ms) {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(ms);
  digitalWrite(BUZZER_PIN, LOW);
}
